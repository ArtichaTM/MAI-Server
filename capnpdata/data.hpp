// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: data.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(ab41f4dcadade2f4);
CAPNP_DECLARE_SCHEMA(fc29d01dbec2b0a9);
CAPNP_DECLARE_SCHEMA(b79e099d1bf4aa84);
CAPNP_DECLARE_SCHEMA(8c3d50b71a5da0df);
CAPNP_DECLARE_SCHEMA(a843988aaddc5a08);
enum class MessageType_a843988aaddc5a08: uint16_t {
  NONE,
  BALL_EXPLODE,
  GAME_EXIT,
  KICKOFF_TIMER_STARTED,
  KICKOFF_TIMER_ENDED,
  REPLAY_STARTED,
};
CAPNP_DECLARE_ENUM(MessageType, a843988aaddc5a08);
CAPNP_DECLARE_SCHEMA(ad6985620d4daba1);
CAPNP_DECLARE_SCHEMA(d06216327693bb76);

}  // namespace schemas
}  // namespace capnp


struct MAIVector {
  MAIVector() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ab41f4dcadade2f4, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MAIRotator {
  MAIRotator() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fc29d01dbec2b0a9, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MAIRLObjectState {
  MAIRLObjectState() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b79e099d1bf4aa84, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MAIGameState {
  MAIGameState() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::MessageType_a843988aaddc5a08 MessageType;

  struct OtherCars;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8c3d50b71a5da0df, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MAIGameState::OtherCars {
  OtherCars() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ad6985620d4daba1, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MAIControls {
  MAIControls() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d06216327693bb76, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class MAIVector::Reader {
public:
  typedef MAIVector Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MAIVector::Builder {
public:
  typedef MAIVector Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MAIVector::Pipeline {
public:
  typedef MAIVector Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MAIRotator::Reader {
public:
  typedef MAIRotator Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int8_t getPitch() const;

  inline  ::int8_t getRoll() const;

  inline  ::int8_t getYaw() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MAIRotator::Builder {
public:
  typedef MAIRotator Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int8_t getPitch();
  inline void setPitch( ::int8_t value);

  inline  ::int8_t getRoll();
  inline void setRoll( ::int8_t value);

  inline  ::int8_t getYaw();
  inline void setYaw( ::int8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MAIRotator::Pipeline {
public:
  typedef MAIRotator Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MAIRLObjectState::Reader {
public:
  typedef MAIRLObjectState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::MAIVector::Reader getPosition() const;

  inline bool hasVelocity() const;
  inline  ::MAIVector::Reader getVelocity() const;

  inline bool hasRotation() const;
  inline  ::MAIRotator::Reader getRotation() const;

  inline bool hasAngularVelocity() const;
  inline  ::MAIVector::Reader getAngularVelocity() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MAIRLObjectState::Builder {
public:
  typedef MAIRLObjectState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::MAIVector::Builder getPosition();
  inline void setPosition( ::MAIVector::Reader value);
  inline  ::MAIVector::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::MAIVector>&& value);
  inline ::capnp::Orphan< ::MAIVector> disownPosition();

  inline bool hasVelocity();
  inline  ::MAIVector::Builder getVelocity();
  inline void setVelocity( ::MAIVector::Reader value);
  inline  ::MAIVector::Builder initVelocity();
  inline void adoptVelocity(::capnp::Orphan< ::MAIVector>&& value);
  inline ::capnp::Orphan< ::MAIVector> disownVelocity();

  inline bool hasRotation();
  inline  ::MAIRotator::Builder getRotation();
  inline void setRotation( ::MAIRotator::Reader value);
  inline  ::MAIRotator::Builder initRotation();
  inline void adoptRotation(::capnp::Orphan< ::MAIRotator>&& value);
  inline ::capnp::Orphan< ::MAIRotator> disownRotation();

  inline bool hasAngularVelocity();
  inline  ::MAIVector::Builder getAngularVelocity();
  inline void setAngularVelocity( ::MAIVector::Reader value);
  inline  ::MAIVector::Builder initAngularVelocity();
  inline void adoptAngularVelocity(::capnp::Orphan< ::MAIVector>&& value);
  inline ::capnp::Orphan< ::MAIVector> disownAngularVelocity();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MAIRLObjectState::Pipeline {
public:
  typedef MAIRLObjectState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::MAIVector::Pipeline getPosition();
  inline  ::MAIVector::Pipeline getVelocity();
  inline  ::MAIRotator::Pipeline getRotation();
  inline  ::MAIVector::Pipeline getAngularVelocity();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MAIGameState::Reader {
public:
  typedef MAIGameState Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCar() const;
  inline  ::MAIRLObjectState::Reader getCar() const;

  inline bool hasBall() const;
  inline  ::MAIRLObjectState::Reader getBall() const;

  inline float getBoostAmount() const;

  inline bool getDead() const;

  inline typename OtherCars::Reader getOtherCars() const;

  inline  ::MAIGameState::MessageType getMessage() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MAIGameState::Builder {
public:
  typedef MAIGameState Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCar();
  inline  ::MAIRLObjectState::Builder getCar();
  inline void setCar( ::MAIRLObjectState::Reader value);
  inline  ::MAIRLObjectState::Builder initCar();
  inline void adoptCar(::capnp::Orphan< ::MAIRLObjectState>&& value);
  inline ::capnp::Orphan< ::MAIRLObjectState> disownCar();

  inline bool hasBall();
  inline  ::MAIRLObjectState::Builder getBall();
  inline void setBall( ::MAIRLObjectState::Reader value);
  inline  ::MAIRLObjectState::Builder initBall();
  inline void adoptBall(::capnp::Orphan< ::MAIRLObjectState>&& value);
  inline ::capnp::Orphan< ::MAIRLObjectState> disownBall();

  inline float getBoostAmount();
  inline void setBoostAmount(float value);

  inline bool getDead();
  inline void setDead(bool value);

  inline typename OtherCars::Builder getOtherCars();
  inline typename OtherCars::Builder initOtherCars();

  inline  ::MAIGameState::MessageType getMessage();
  inline void setMessage( ::MAIGameState::MessageType value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MAIGameState::Pipeline {
public:
  typedef MAIGameState Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::MAIRLObjectState::Pipeline getCar();
  inline  ::MAIRLObjectState::Pipeline getBall();
  inline typename OtherCars::Pipeline getOtherCars();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MAIGameState::OtherCars::Reader {
public:
  typedef OtherCars Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAllies() const;
  inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Reader getAllies() const;

  inline bool hasEnemies() const;
  inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Reader getEnemies() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MAIGameState::OtherCars::Builder {
public:
  typedef OtherCars Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAllies();
  inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Builder getAllies();
  inline void setAllies( ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Builder initAllies(unsigned int size);
  inline void adoptAllies(::capnp::Orphan< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>> disownAllies();

  inline bool hasEnemies();
  inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Builder getEnemies();
  inline void setEnemies( ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Builder initEnemies(unsigned int size);
  inline void adoptEnemies(::capnp::Orphan< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>> disownEnemies();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MAIGameState::OtherCars::Pipeline {
public:
  typedef OtherCars Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MAIControls::Reader {
public:
  typedef MAIControls Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getThrottle() const;

  inline float getSteer() const;

  inline float getPitch() const;

  inline float getYaw() const;

  inline float getRoll() const;

  inline bool getBoost() const;

  inline bool getJump() const;

  inline bool getHandbrake() const;

  inline float getDodgeForward() const;

  inline float getDodgeStrafe() const;

  inline bool getSkip() const;

  inline bool getReset() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MAIControls::Builder {
public:
  typedef MAIControls Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getThrottle();
  inline void setThrottle(float value);

  inline float getSteer();
  inline void setSteer(float value);

  inline float getPitch();
  inline void setPitch(float value);

  inline float getYaw();
  inline void setYaw(float value);

  inline float getRoll();
  inline void setRoll(float value);

  inline bool getBoost();
  inline void setBoost(bool value);

  inline bool getJump();
  inline void setJump(bool value);

  inline bool getHandbrake();
  inline void setHandbrake(bool value);

  inline float getDodgeForward();
  inline void setDodgeForward(float value);

  inline float getDodgeStrafe();
  inline void setDodgeStrafe(float value);

  inline bool getSkip();
  inline void setSkip(bool value);

  inline bool getReset();
  inline void setReset(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MAIControls::Pipeline {
public:
  typedef MAIControls Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline float MAIVector::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float MAIVector::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MAIVector::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float MAIVector::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float MAIVector::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MAIVector::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float MAIVector::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float MAIVector::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MAIVector::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t MAIRotator::Reader::getPitch() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int8_t MAIRotator::Builder::getPitch() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MAIRotator::Builder::setPitch( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t MAIRotator::Reader::getRoll() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int8_t MAIRotator::Builder::getRoll() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MAIRotator::Builder::setRoll( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t MAIRotator::Reader::getYaw() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int8_t MAIRotator::Builder::getYaw() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MAIRotator::Builder::setYaw( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool MAIRLObjectState::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MAIRLObjectState::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::MAIVector::Reader MAIRLObjectState::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::MAIVector>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::MAIVector::Builder MAIRLObjectState::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::MAIVector>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MAIVector::Pipeline MAIRLObjectState::Pipeline::getPosition() {
  return  ::MAIVector::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MAIRLObjectState::Builder::setPosition( ::MAIVector::Reader value) {
  ::capnp::_::PointerHelpers< ::MAIVector>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::MAIVector::Builder MAIRLObjectState::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::MAIVector>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MAIRLObjectState::Builder::adoptPosition(
    ::capnp::Orphan< ::MAIVector>&& value) {
  ::capnp::_::PointerHelpers< ::MAIVector>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MAIVector> MAIRLObjectState::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::MAIVector>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MAIRLObjectState::Reader::hasVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool MAIRLObjectState::Builder::hasVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::MAIVector::Reader MAIRLObjectState::Reader::getVelocity() const {
  return ::capnp::_::PointerHelpers< ::MAIVector>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::MAIVector::Builder MAIRLObjectState::Builder::getVelocity() {
  return ::capnp::_::PointerHelpers< ::MAIVector>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MAIVector::Pipeline MAIRLObjectState::Pipeline::getVelocity() {
  return  ::MAIVector::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MAIRLObjectState::Builder::setVelocity( ::MAIVector::Reader value) {
  ::capnp::_::PointerHelpers< ::MAIVector>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::MAIVector::Builder MAIRLObjectState::Builder::initVelocity() {
  return ::capnp::_::PointerHelpers< ::MAIVector>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void MAIRLObjectState::Builder::adoptVelocity(
    ::capnp::Orphan< ::MAIVector>&& value) {
  ::capnp::_::PointerHelpers< ::MAIVector>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MAIVector> MAIRLObjectState::Builder::disownVelocity() {
  return ::capnp::_::PointerHelpers< ::MAIVector>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool MAIRLObjectState::Reader::hasRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool MAIRLObjectState::Builder::hasRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::MAIRotator::Reader MAIRLObjectState::Reader::getRotation() const {
  return ::capnp::_::PointerHelpers< ::MAIRotator>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::MAIRotator::Builder MAIRLObjectState::Builder::getRotation() {
  return ::capnp::_::PointerHelpers< ::MAIRotator>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MAIRotator::Pipeline MAIRLObjectState::Pipeline::getRotation() {
  return  ::MAIRotator::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void MAIRLObjectState::Builder::setRotation( ::MAIRotator::Reader value) {
  ::capnp::_::PointerHelpers< ::MAIRotator>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::MAIRotator::Builder MAIRLObjectState::Builder::initRotation() {
  return ::capnp::_::PointerHelpers< ::MAIRotator>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void MAIRLObjectState::Builder::adoptRotation(
    ::capnp::Orphan< ::MAIRotator>&& value) {
  ::capnp::_::PointerHelpers< ::MAIRotator>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MAIRotator> MAIRLObjectState::Builder::disownRotation() {
  return ::capnp::_::PointerHelpers< ::MAIRotator>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool MAIRLObjectState::Reader::hasAngularVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool MAIRLObjectState::Builder::hasAngularVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::MAIVector::Reader MAIRLObjectState::Reader::getAngularVelocity() const {
  return ::capnp::_::PointerHelpers< ::MAIVector>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::MAIVector::Builder MAIRLObjectState::Builder::getAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::MAIVector>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MAIVector::Pipeline MAIRLObjectState::Pipeline::getAngularVelocity() {
  return  ::MAIVector::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void MAIRLObjectState::Builder::setAngularVelocity( ::MAIVector::Reader value) {
  ::capnp::_::PointerHelpers< ::MAIVector>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::MAIVector::Builder MAIRLObjectState::Builder::initAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::MAIVector>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void MAIRLObjectState::Builder::adoptAngularVelocity(
    ::capnp::Orphan< ::MAIVector>&& value) {
  ::capnp::_::PointerHelpers< ::MAIVector>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MAIVector> MAIRLObjectState::Builder::disownAngularVelocity() {
  return ::capnp::_::PointerHelpers< ::MAIVector>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool MAIGameState::Reader::hasCar() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MAIGameState::Builder::hasCar() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::MAIRLObjectState::Reader MAIGameState::Reader::getCar() const {
  return ::capnp::_::PointerHelpers< ::MAIRLObjectState>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::MAIRLObjectState::Builder MAIGameState::Builder::getCar() {
  return ::capnp::_::PointerHelpers< ::MAIRLObjectState>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MAIRLObjectState::Pipeline MAIGameState::Pipeline::getCar() {
  return  ::MAIRLObjectState::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MAIGameState::Builder::setCar( ::MAIRLObjectState::Reader value) {
  ::capnp::_::PointerHelpers< ::MAIRLObjectState>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::MAIRLObjectState::Builder MAIGameState::Builder::initCar() {
  return ::capnp::_::PointerHelpers< ::MAIRLObjectState>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MAIGameState::Builder::adoptCar(
    ::capnp::Orphan< ::MAIRLObjectState>&& value) {
  ::capnp::_::PointerHelpers< ::MAIRLObjectState>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MAIRLObjectState> MAIGameState::Builder::disownCar() {
  return ::capnp::_::PointerHelpers< ::MAIRLObjectState>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool MAIGameState::Reader::hasBall() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool MAIGameState::Builder::hasBall() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::MAIRLObjectState::Reader MAIGameState::Reader::getBall() const {
  return ::capnp::_::PointerHelpers< ::MAIRLObjectState>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::MAIRLObjectState::Builder MAIGameState::Builder::getBall() {
  return ::capnp::_::PointerHelpers< ::MAIRLObjectState>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::MAIRLObjectState::Pipeline MAIGameState::Pipeline::getBall() {
  return  ::MAIRLObjectState::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MAIGameState::Builder::setBall( ::MAIRLObjectState::Reader value) {
  ::capnp::_::PointerHelpers< ::MAIRLObjectState>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::MAIRLObjectState::Builder MAIGameState::Builder::initBall() {
  return ::capnp::_::PointerHelpers< ::MAIRLObjectState>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void MAIGameState::Builder::adoptBall(
    ::capnp::Orphan< ::MAIRLObjectState>&& value) {
  ::capnp::_::PointerHelpers< ::MAIRLObjectState>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::MAIRLObjectState> MAIGameState::Builder::disownBall() {
  return ::capnp::_::PointerHelpers< ::MAIRLObjectState>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float MAIGameState::Reader::getBoostAmount() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float MAIGameState::Builder::getBoostAmount() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MAIGameState::Builder::setBoostAmount(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool MAIGameState::Reader::getDead() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool MAIGameState::Builder::getDead() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void MAIGameState::Builder::setDead(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline typename MAIGameState::OtherCars::Reader MAIGameState::Reader::getOtherCars() const {
  return typename MAIGameState::OtherCars::Reader(_reader);
}
inline typename MAIGameState::OtherCars::Builder MAIGameState::Builder::getOtherCars() {
  return typename MAIGameState::OtherCars::Builder(_builder);
}
#if !CAPNP_LITE
inline typename MAIGameState::OtherCars::Pipeline MAIGameState::Pipeline::getOtherCars() {
  return typename MAIGameState::OtherCars::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename MAIGameState::OtherCars::Builder MAIGameState::Builder::initOtherCars() {
  _builder.getPointerField(::capnp::bounded<2>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<3>() * ::capnp::POINTERS).clear();
  return typename MAIGameState::OtherCars::Builder(_builder);
}
inline  ::MAIGameState::MessageType MAIGameState::Reader::getMessage() const {
  return _reader.getDataField< ::MAIGameState::MessageType>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::MAIGameState::MessageType MAIGameState::Builder::getMessage() {
  return _builder.getDataField< ::MAIGameState::MessageType>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void MAIGameState::Builder::setMessage( ::MAIGameState::MessageType value) {
  _builder.setDataField< ::MAIGameState::MessageType>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool MAIGameState::OtherCars::Reader::hasAllies() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool MAIGameState::OtherCars::Builder::hasAllies() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Reader MAIGameState::OtherCars::Reader::getAllies() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Builder MAIGameState::OtherCars::Builder::getAllies() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void MAIGameState::OtherCars::Builder::setAllies( ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Builder MAIGameState::OtherCars::Builder::initAllies(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void MAIGameState::OtherCars::Builder::adoptAllies(
    ::capnp::Orphan< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>> MAIGameState::OtherCars::Builder::disownAllies() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool MAIGameState::OtherCars::Reader::hasEnemies() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool MAIGameState::OtherCars::Builder::hasEnemies() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Reader MAIGameState::OtherCars::Reader::getEnemies() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Builder MAIGameState::OtherCars::Builder::getEnemies() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void MAIGameState::OtherCars::Builder::setEnemies( ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>::Builder MAIGameState::OtherCars::Builder::initEnemies(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void MAIGameState::OtherCars::Builder::adoptEnemies(
    ::capnp::Orphan< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>> MAIGameState::OtherCars::Builder::disownEnemies() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MAIRLObjectState,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline float MAIControls::Reader::getThrottle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float MAIControls::Builder::getThrottle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setThrottle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float MAIControls::Reader::getSteer() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float MAIControls::Builder::getSteer() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setSteer(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float MAIControls::Reader::getPitch() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float MAIControls::Builder::getPitch() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setPitch(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float MAIControls::Reader::getYaw() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float MAIControls::Builder::getYaw() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setYaw(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline float MAIControls::Reader::getRoll() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline float MAIControls::Builder::getRoll() {
  return _builder.getDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setRoll(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline bool MAIControls::Reader::getBoost() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<160>() * ::capnp::ELEMENTS);
}

inline bool MAIControls::Builder::getBoost() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<160>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setBoost(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<160>() * ::capnp::ELEMENTS, value);
}

inline bool MAIControls::Reader::getJump() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<161>() * ::capnp::ELEMENTS);
}

inline bool MAIControls::Builder::getJump() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<161>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setJump(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<161>() * ::capnp::ELEMENTS, value);
}

inline bool MAIControls::Reader::getHandbrake() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<162>() * ::capnp::ELEMENTS);
}

inline bool MAIControls::Builder::getHandbrake() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<162>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setHandbrake(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<162>() * ::capnp::ELEMENTS, value);
}

inline float MAIControls::Reader::getDodgeForward() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline float MAIControls::Builder::getDodgeForward() {
  return _builder.getDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setDodgeForward(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline float MAIControls::Reader::getDodgeStrafe() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}

inline float MAIControls::Builder::getDodgeStrafe() {
  return _builder.getDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setDodgeStrafe(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<7>() * ::capnp::ELEMENTS, value);
}

inline bool MAIControls::Reader::getSkip() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<163>() * ::capnp::ELEMENTS);
}

inline bool MAIControls::Builder::getSkip() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<163>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setSkip(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<163>() * ::capnp::ELEMENTS, value);
}

inline bool MAIControls::Reader::getReset() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<164>() * ::capnp::ELEMENTS);
}

inline bool MAIControls::Builder::getReset() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<164>() * ::capnp::ELEMENTS);
}
inline void MAIControls::Builder::setReset(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<164>() * ::capnp::ELEMENTS, value);
}


CAPNP_END_HEADER

